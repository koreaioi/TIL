# CPU 캐시와 메인 메모리 간의 데이터 불일치

![image](https://github.com/user-attachments/assets/7bc1c8b9-4ec3-41e8-a594-5b553f318746)

- CPU 1에는 Thread 1이 실행, 캐시에 counter = 7
- CPU 2에는 Thread 2이 실행, 캐시에 counter = 0
- RAM(메인 메모리) 여전히 counter = 0 으로 저장되어 있다.
- CPU 캐시와 메인 메모리 간의 데이터 일관성이 깨진 것이다.

## Why?

오늘날 대부분의 컴퓨터는 멀티 코어 프로세서를 사용   
각 코어는 별도의 캐시를 가진다. -> 코어별 동기화가 되어있지 않으면 데이터 일관성이 깨짐.
- 코어는 메모리에서 읽어온 값을 캐시에 저장
- 같은 값을 읽을 때 먼저 캐시에 있는 지 확인한다.
- 따라서 메모리에 값이 변경되어도, 캐시에는 변경이 반영되어있지 X

## Solution

이런 데이터 불일치를 해결하기 위해서 volatile을 사용한다.   
변수 앞에 `valatile`을 사용하면 코어가 변수의 값을 읽어올 때, 캐시가 아닌 메모리에서 읽어와 캐시와 메모리간의 불일치를 해결할 수 있다.   

# valatile과 가시성
가시성 문제는 멀티쓰레드 프로그래밍에서 한 쓰레드에서 변경된 데이터가 다른 쓰레드에 즉시 보이지 않는 상황   
즉, 쓰레드 간 데이터 변경이 반영되지 않는 것이고 이런 이슈는 데이터 일관성 문제로 이어질 수 있다.   

따라서 valtaile은 변수의 가시성을 보장하는데 중요한 역할을한다.   
변수의 값을 항상 메인 메모리에서 읽고 쓸 수 있도록 보장한다.


# 원자성
원자성이란 `한 번에 완전히 수행되는, 쪼개질 수 없는 연산`을 의미한다.

- `불가분성`: 중간에 끼어들 수 없는 단일 단위의 연산
- `중단 불간으성`: 원자적 연산은 중간에 중단되지 않는다.
- `일관성 보장`: 원자적 연산이 보장되면 여러 쓰레드가 동시에 해당 연산을 수행해도 데이터 일관성이 유지 된다. -> 데이터 경쟁을 방지

## volatile의 기본 원자성 보장
기본 원자성은 단일 메모리 액세스로 수행되는 단순한 연산이 중단없이 수행됨이다.      
자바에서는 단일 변수 읽기와 쓰기 등이 기본적으로 원자성을 가진다.   

단, 64비트인 long과 double은 예외가 있다.   
두 타입은 32bit씩 두 번의 연산으로 나누어 실행되므로 다른 스레드가 개입할 경우 잘못된 값을 읽어나가는 문제가 있을 수 있다.

volatile : 원자성을 보장하기 위한 또 다른 접근
Java는 이런 문제를 해결하기 위해서 volatile이라는 키워드를 제공합니다. 아래와 같이 필드에 사용할 수 있습니다.

```java
public class Test {
    public volatile long sharedValue;
}
```
volatile 필드가 원자성을 제공하는 자세한 원리에 대해서는 나중에 설명할 기회가 있기를 바랍니다. 지금 이 포스팅에서는 volatile이 어떻게 동작하는지에 대해서만 이야기 할게요.

volatile은 해당 필드에 접근할 때 lock을 걸도록 합니다. 지정한 메서드나 지정한 블록에 thread-safe를 보장하는 synchronized와는 다르게요. 해당 필드의 접근에 대해서만 원자성을 보장합니다. 한 스레드가 하나의 long 변수의 32bit를 쓰는 도중에 다른 스레드가 나머지 32bit를 쓰거나 읽지 못하도록 하는 것이에요.

그러므로 하나의 스레드가 sharedValue에 값을 쓰고, 나머지 스레드들은 값을 읽어가기만 하는 상황을 가정한다면, 필드에 volatile 키워드를 사용하는 것만으로 적절한 임계영역의 처리가 될 것입니다.
하지만 여러 스레드가 동시에, sharedValue에 단순히 접근하는 것 이상의 여러 연산을 수행하게 된다면 동시성을 보장하지 못할 거에요.
