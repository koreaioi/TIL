# 프린터 예제

인터럽트가 실제로 어디서 활용되는 지 실용적인 예제를 만들어, 몸으로 느껴보는 게 좋을 것이다.

```java
package thread.control.printer;

import java.util.Queue;
import java.util.Scanner;
import java.util.concurrent.ConcurrentLinkedQueue;

import static util.MyLogger.log;
import static util.ThreadUtils.sleep;

public class MyPrinterV1 {

    public static void main(String[] args) {
        Printer printer = new Printer();
        Thread printerThread = new Thread(printer, "printer");
        printerThread.start();

        Scanner userInput = new Scanner(System.in);
        while (true) {
            log("프린터할 문서를 입력하세요. 종료(q): ");
            String input = userInput.nextLine();
            if (input.equals("q")) {
                printer.work = false;
                break;
            }
            printer.addJob(input);
        }
    }

    static class Printer implements Runnable {
        volatile boolean work = true;
        Queue<String> jobQueue = new ConcurrentLinkedQueue<>();

        @Override
        public void run() {
            while (work) {
                if (jobQueue.isEmpty()) {
                    continue;
                }

                String job = jobQueue.poll();
                log("출력 시작: " + job + ", 대기 문서: " + jobQueue);
                sleep(3000);
                log("출력 완료");
            }
            log("프린터 종료");
        }

        public void addJob(String input) {
            jobQueue.add(input);
        }

    }

}

```

### 아쉬운 점 1 

위 코드의 아쉬운 점은 sleep(3000)이다.
사용자가 `q`를 입력했음에도 최악의 경우, Printer가 3초 뒤에 종료될 수 있는 원인이기 때문이다.

이런 단점을 해결하고자, 인터럽트를 도입하고 느린 반응성을 개선해보자!

### 느린 반응성을 Interrupt로 개선하기

```java
package thread.control.printer;

import java.util.Queue;
import java.util.Scanner;
import java.util.concurrent.ConcurrentLinkedQueue;

import static util.MyLogger.log;
import static util.ThreadUtils.sleep;

public class MyPrinterV2 {

    public static void main(String[] args) {
        Printer printer = new Printer();
        Thread printerThread = new Thread(printer, "printer");
        printerThread.start();

        Scanner userInput = new Scanner(System.in);
        while (true) {
            log("프린터할 문서를 입력하세요. 종료(q): ");
            String input = userInput.nextLine();
            if (input.equals("q")) {
                printer.work = false;
                printerThread.interrupt();
                break;
            }
            printer.addJob(input);
        }
    }

    static class Printer implements Runnable {
        volatile boolean work = true;
        Queue<String> jobQueue = new ConcurrentLinkedQueue<>();

        @Override
        public void run() {
            while (work) {
                if (jobQueue.isEmpty()) {
                    continue;
                }

                try {
                    String job = jobQueue.poll();
                    log("출력 시작: " + job + ", 대기 문서: " + jobQueue);
                    Thread.sleep(3000);
                    log("출력 완료");
                } catch (InterruptedException e) {
                    log("인터럽트!");
                    break;
                }

            }
            log("프린터 종료");
        }

        public void addJob(String input) {
            jobQueue.add(input);
        }

    }

}

```

문제가 된 부분은 Thread.sleep()으로 인하여, while 조건문을 확인하는 게 느려졌기 때문이다.
인터럽트를 발생시키고, 실제 InterruptedException을 처리하는 로직과 while문을 빠져나올 수 있게 한다면 사용자가 q를 입력하는 순간 곧바로 프로그램이 종료된다.


### 아쉬운 점 2
work라는 flag변수 대신, Thread의 인터럽트 상태 변수를 사용할 수 있다.
또한 work에 false가 되어서, 반복문 내부를 실행하지 않는데, 인터럽트 상태는 계속 유지되는 문제도 존재한다.

```java
package thread.control.printer;

import java.util.Queue;
import java.util.Scanner;
import java.util.concurrent.ConcurrentLinkedQueue;

import static util.MyLogger.log;
import static util.ThreadUtils.sleep;

public class MyPrinterV2 {

    public static void main(String[] args) {
        Printer printer = new Printer();
        Thread printerThread = new Thread(printer, "printer");
        printerThread.start();

        Scanner userInput = new Scanner(System.in);
        while (true) {
            log("프린터할 문서를 입력하세요. 종료(q): ");
            String input = userInput.nextLine();
            if (input.equals("q")) {
                printerThread.interrupt();
                break;
            }
            printer.addJob(input);
        }
    }

    static class Printer implements Runnable {
        Queue<String> jobQueue = new ConcurrentLinkedQueue<>();

        @Override
        public void run() {
            while (!Thread.interrupted()) {
                if (jobQueue.isEmpty()) {
                    continue;
                }

                try {
                    String job = jobQueue.poll();
                    log("출력 시작: " + job + ", 대기 문서: " + jobQueue);
                    Thread.sleep(3000);
                    log("출력 완료");
                } catch (InterruptedException e) {
                    log("인터럽트!");
                    break;
                }

            }
            log("프린터 종료");
        }

        public void addJob(String input) {
            jobQueue.add(input);
        }

    }

}

```

이렇게 함으로써, main에서 flag와 인터럽트 두가지를 사용해야하는 불편함이 있지만, 이렇게 한가지 변수를 사용해 코드를 개선할 수 있다.
결국 스레드의 동작 여부는 인터럽트 여부와 같기 때문이다.

어떤 스레드의 기능이 A라고 할때, 그 기능 A을 수행하기 위한 두가지 조건이 필요한 것이다.
1. 기능을 수행하기 위한 충분한 재료. (여기선 inputValue)
2. 인터럽트가 아님.